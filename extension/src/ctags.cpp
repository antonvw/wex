////////////////////////////////////////////////////////////////////////////////
// Name:      ctags.cpp
// Purpose:   Implementation of class wxExCTags
//            http://ctags.sourceforge.net/ctags.html
// Author:    Anton van Wezenbeek
// Copyright: (c) 2017 Anton van Wezenbeek
////////////////////////////////////////////////////////////////////////////////

#include <algorithm>
#include <vector>
#include <easylogging++.h>
#include <wx/choicdlg.h>
#include <wx/config.h>
#include <wx/log.h>
#include <wx/extension/ctags.h>
#include <wx/extension/frame.h>
#include <wx/extension/frd.h>
#include <wx/extension/path.h>
#include <wx/extension/util.h>
#include "readtags.h"

class wxExCTagsEntry
{
public:
  wxExCTagsEntry(const tagEntry& entry)
    : m_LineNumber(entry.address.lineNumber)
    , m_Path(entry.file)
    , m_Pattern(entry.address.pattern != nullptr ? 
      // prepend colon to force ex command
      ":" + std::string(entry.address.pattern): std::string()) {
    // replace any * with ., somehow the pattern generated by
    // ctags mixes regex with non regex....
    std::replace(m_Pattern.begin(), m_Pattern.end(), '*', '.');};
  const std::string GetName() const {return 
    wxConfigBase::Get()->ReadBool(_("vi tag fullpath"), false) ?
      m_Path.Path().string(): m_Path.GetFullName();};
  void OpenFile(wxExFrame* frame) const
  {
    frame->OpenFile(m_Path, 
      wxExControlData().Line(m_LineNumber).Command(m_Pattern));
  }
private:
  const wxExPath m_Path;
  const int m_LineNumber;
  std::string m_Pattern;
};

wxExCTags::wxExCTags(wxExFrame* frame, const std::string& filename)
  : m_Frame(frame)
  , m_Iterator(m_Matches.begin())
{
  tagFileInfo info;

  for (const auto & it : std::vector < std::string > {
    "./", wxExConfigDir() + "/"})
  {
    if ((m_File = tagsOpen(std::string(it + filename).c_str(), &info)) != nullptr)
    {
      return; // finish, we found a file
    }
  }
}

wxExCTags::~wxExCTags()
{
  tagsClose(m_File);
}

bool wxExCTags::Find(const std::string& name)
{
  if (m_File == nullptr) return false;

  if (name.empty())
  {
    return Next();
  }

  tagEntry entry;
  
  if (tagsFind(m_File, &entry, name.c_str(), TAG_FULLMATCH) == TagFailure)
  {
    wxLogStatus("tag not found: " + wxString(name));
    return false;
  }
  
  const wxExCTagsEntry ct(entry);

  m_Matches.clear();
  m_Matches.insert({ct.GetName(), ct});
  m_Iterator = m_Matches.begin();
  
  while (tagsFindNext(m_File, &entry) == TagSuccess)
  {
    const wxExCTagsEntry ct(entry);
    m_Matches.insert({ct.GetName(), ct});
  }

  VLOG(9) << "ctags matches: " << m_Matches.size();

  if (m_Matches.size() == 1)
  {
    m_Matches.begin()->second.OpenFile(m_Frame);
  }
  else
  {
    wxArrayString as;
    for (const auto& it : m_Matches) as.Add(it.second.GetName());
    wxMultiChoiceDialog dialog(m_Frame,
      _("Input") + ":", 
      _("Select File"),
      as);
    if (dialog.ShowModal() != wxID_OK) return false;
    
    for (const auto& sel : dialog.GetSelections())
    {
      m_Iterator = m_Matches.find(as[sel].ToStdString());
      m_Iterator->second.OpenFile(m_Frame);
    }
  }

  wxExFindReplaceData::Get()->SetFindString(name);

  return true;
}  

bool wxExCTags::Next()
{
  if (m_Matches.size() <= 1)
  {
    return false;
  }

  if (++m_Iterator == m_Matches.end())
  {
    m_Iterator = m_Matches.begin();
  }

  m_Iterator->second.OpenFile(m_Frame);

  return true;
}

bool wxExCTags::Previous()
{
  if (m_Matches.size() <= 1)
  {
    return false;
  }

  if (m_Iterator == m_Matches.begin())
  {
    m_Iterator = m_Matches.end();
  }

  m_Iterator--;
  m_Iterator->second.OpenFile(m_Frame);

  return true;
}
